"use strict";

const fs = require("fs");
const path = require("path");
const commander = require("commander");
const Overflow = require("overflow-js").Overflow;

const banks = [];

function parseHexPair(string, index) {
  return parseInt(string.substr(index, 2), 16);
}

function writeLogo(buffer) {
  const logoBuffer = Buffer.from([
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
    0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
    0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E
  ]);
  
  logoBuffer.copy(buffer, 0x0104);
}

function writeTitle(buffer, title) {
  if(title.length > 11) {
    console.warn(`warning: title longer than 11 characters, later characters will be ignored`);
  }
  
  if(/^[A-Z0-9 ]*$/g.test(title) == false) {
    console.error("title may only have uppercase letters, digits, and spaces");
    process.exit(1);
  }
  
  const startAddress = 0x0134;
  buffer.fill(0x00, startAddress, startAddress + 11);
  buffer.write(title, startAddress, Math.min(title.length, 11), "ascii");
}

function writeManufacturerCode(buffer, code) {
  if(code.length > 4) {
    console.warn(`warning: manufacturer code longer than 4 characters, later characters will be ignored`);
  }
  
  if(/^[A-Z0-9 ]*$/g.test(code) == false) {
    console.error("manufacturer code may only have uppercase letters, digits, and spaces");
    process.exit(1);
  }
  
  const startAddress = 0x013F;
  buffer.fill(0x00, startAddress, startAddress + 4);
  buffer.write(code, startAddress, Math.min(code.length, 4), "ascii");
}

function writeCGBFlag(buffer, flag) {
  buffer.writeUInt8(flag, 0x0143);
}

function writeLicenseeCode(buffer, code) {
  if(code.length > 2) {
    console.warn(`warning: licensee code longer than 2 characters, later characters will be ignored`);
  }
  
  if(/^[a-zA-Z0-9 ]*$/g.test(code) == false) {
    console.error("licensee code may only have letters, digits, and spaces");
    process.exit(1);
  }
  
  const startAddress = 0x0144;
  buffer.fill(0xFF, startAddress, startAddress + 2);
  buffer.write(code, startAddress, Math.min(code.length, 2), "ascii");
}

function writeSGBFlag(buffer, flag) {
  buffer.writeUInt8(flag, 0x0146);
}

function writeCartridgeType(buffer, type) {
  buffer.writeUInt8(type, 0x0147);
}

function writeROMSize(buffer, size) {
  buffer.writeUInt8(size, 0x0148);
}

function writeRAMSize(buffer, size) {
  buffer.writeUInt8(size, 0x0149);
}

function writeDestinationCode(buffer, code) {
  buffer.writeUInt8(code, 0x014A);
}

function writeOldLicenseeCode(buffer, code) {
  buffer.writeUInt8(code, 0x014B);
}

function writeROMVersion(buffer, version) {
  buffer.writeUInt8(version, 0x014C);
}

function writeHeaderChecksum(buffer) {
  let x = Overflow.ubyte(0);
  for(let index = 0x0134; index <= 0x014C; index++) {
    x = x.minus(buffer[index]).minus(1);
  }
  buffer.writeUInt8(x.value, 0x014D);
}

function writeROMChecksum(buffer) {
  let x = Overflow.ushort(0);
  for(let index = 0x00; index < buffer.length; index++) {
    if(index == 0x014E || index == 0x014F) {
      continue;
    }
    x = x.plus(buffer[index]);
  }
  buffer.writeUInt16BE(x.value, 0x014E);
}

function processMap(mapFilePath, symOutputPath) {
  if(fs.existsSync(mapFilePath) == false) {
    return;
  }
  
  const symbolRegex = /^[\s]+([0-9A-F]{8})  _([a-zA-Z0-9_]+)/;
  const areaRegex = /^(_[A-Za-z_0-9]+)[\s]+([0-9A-F]{8})[\s]+([0-9A-F]{8})/;
  
  const text = fs.readFileSync(mapFilePath, "utf8");
  const lines = text.split(/[\n\r]+/g);
  const addresses = [];
  lines.forEach((line) => {
    const symbolMatch = symbolRegex.exec(line);
    if(symbolMatch != null) {
      const address = symbolMatch[1];
      const symbol = symbolMatch[2];
      
      addresses.push({
        "address" : address,
        "symbol" : symbol
      });
    }
    
    const areaMatch = areaRegex.exec(line);
    if(areaMatch != null) {
      const name = areaMatch[1];
      const address = areaMatch[2];
      const size = areaMatch[3];
      
      if(name.indexOf("_CODE") == 0) {
        const sizeNumber = parseInt(size, 16);
        
        if(sizeNumber > 16384) {
          console.error(`error: area size overflow. ${name} is ${sizeNumber} bytes. Must be no larger than 16384. Bank moar.`);
          process.exit(1);
        }
      }
      
      if(name.indexOf("_CODE_") == 0) {
        const bank = {
          "name" : name,
          "address" : parseInt(address, 16),
          "offset" : parseInt(address.substring(0, 4), 16) * 0x4000,
          "size" : parseInt(size, 16)
        };
        
        banks.push(bank);
      }
    }
  });
  
  const symbolLines = [
    "; Generated by IHX2GB",
    ""
  ];
  addresses.forEach((address) => {
    symbolLines.push(`${address.address.substr(2, 2)}:${address.address.substr(4)} ${address.symbol}`);
  });
  
  fs.writeFileSync(symOutputFilePath, symbolLines.join("\n"));
}

commander
  .usage("[options] <in_file> <out_file>")
  .option("-n, --name [value]", "The name in the header. Default: \"MY GAME\"", "MY GAME")
  .option("-m, --manufacturer [code]", "The manufacturer code. Default: \"\"", "")
  .option("-c, --cgb [flag]", "The decimal Game Boy Color support flag. 128 for CGB+GB, 192 for CGB-only. Default: 0", "0", parseInt)
  .option("-l, --licensee [code]", "The ASCII licensee code. Default: \"00\"", "00")
  .option("-s, --sgb [flag]", "The decimal Super Game Boy support flag. 3 to enable. Default: 0", "0", parseInt)
  .option("-t, --cartridge [type]", "The decimal cartridge type. Default: 0", "0", parseInt)
  .option("-r, --rom [code]", "The decimal ROM size code. File will be 32KB << value, except for 82, 83, and 84. Default: 0", "0", parseInt)
  .option("-a, --ram [code]", "The decimal external RAM size code. Default: 0", "0", parseInt)
  .option("-d, --destination [code]", "The destination code. 0 for Japan, 1 for international. Default: 1", "1", parseInt)
  .option("--oldlicensee [code]", "The decimal old licensee code. 51 to use new licensee code. SGB will not work if != 51. Default: 51", "51", parseInt)
  .option("-v, --version [version]", "The ROM version. Default: 0", "0", parseInt)

commander.on("--help", () => {
  console.log("Go to http://gbdev.gg8.se/wiki/articles/The_Cartridge_Header for header details, including values for Cartridge Type, ROM Size, and RAM Size. That site lists codes in hex, but must be provided here in decimal.");
  console.log("");
});

commander.parse(process.argv);

if(commander.rom > 8) {
  let n = 32768;
  for(let i=0; i < commander.rom; i++) {
    n *= 2;
  }
  console.error("rom size codes > 8 unsupported. Fun fact, you asked me to make a file " + (n) + " bytes big! Wow!");
  process.exit(1);
}

if(commander.args.length != 2) {
  console.error("must provide both an input and output file");
  process.exit(1);
}

const inputFilePath = path.resolve(commander.args[0]);
const outputFilePath = path.resolve(commander.args[1]);

const inputFileDirectory = path.dirname(inputFilePath);
const inputFileBasename = path.basename(inputFilePath, path.extname(inputFilePath));
const mapFilePath = path.join(inputFileDirectory, inputFileBasename + ".map");

const outputFileDirectory = path.dirname(outputFilePath);
const outputFileBasename = path.basename(outputFilePath, path.extname(outputFilePath));
const symOutputFilePath = path.join(outputFileDirectory, outputFileBasename + ".sym");

processMap(mapFilePath, symOutputFilePath);

const ihxText = fs.readFileSync(inputFilePath, { "encoding" : "utf8" });
const ihxRecords = ihxText.split(/[\n\r]+/g).filter((record) => { return record.length > 0; });
const gbBuffer = Buffer.alloc(32768 << commander.rom, 0xFF);

let baseAddress = 0;

let writingBank = false;
let bankHead = 0;
let bankIndex = -1;

ihxRecords.forEach((record) => {
  let head = 0;
  
  if(record[head] != ":") {
    console.error("not an ihx file");
    process.exit(1);
  }
  
  head +=1;
  
  const dataLength = parseHexPair(record, head);
  head += 2;
  
  const address = baseAddress + (parseHexPair(record, head) << 8) + parseHexPair(record, head + 2);
  head += 4;
  
  const type = parseHexPair(record, head);
  head += 2;
  
  if(type == 0) {
    // Data Record, copy bytes
    
    if(address >= 0x8000) {
      console.error(`error: write address ${address} above ${0x8000}. wat.`);
      process.exit(1);
    }
    
    if(address >= 0x4000) {
      if(writingBank == false || (writingBank == true && address <= bankHead)) {
        writingBank = true;
        bankHead = address;
        bankIndex++;
      }
    } else {
      writingBank = false;
    }
    
    for(let index = 0; index < dataLength; index++) {
      const byte = parseHexPair(record, head);
      head += 2;
      
      if(writingBank) {
        gbBuffer[banks[bankIndex].offset + (address - 0x4000) + index] = byte;
      } else {
        gbBuffer[address + index] = byte;
      }
    }
  } else if(type == 1) {
    // EOF Record.
  } else {
    console.error("unsupported record type");
    process.exit(1);
  }
});

writeLogo(gbBuffer);
writeTitle(gbBuffer, commander.name);
writeManufacturerCode(gbBuffer, commander.manufacturer);
writeCGBFlag(gbBuffer, commander.cgb);
writeLicenseeCode(gbBuffer, commander.licensee);
writeSGBFlag(gbBuffer, commander.sgb);
writeCartridgeType(gbBuffer, commander.cartridge);
writeROMSize(gbBuffer, commander.rom);
writeRAMSize(gbBuffer, commander.ram);
writeDestinationCode(gbBuffer, commander.destination);
writeOldLicenseeCode(gbBuffer, commander.oldlicensee);
writeROMVersion(gbBuffer, commander.version);
writeHeaderChecksum(gbBuffer);
writeROMChecksum(gbBuffer);

fs.writeFileSync(outputFilePath, gbBuffer);
